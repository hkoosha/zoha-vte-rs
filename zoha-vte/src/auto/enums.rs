// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use zoha_vte_sys as ffi;

use glib::{prelude::*,translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorBlinkMode")]
pub enum CursorBlinkMode {
    #[doc(alias = "VTE_CURSOR_BLINK_SYSTEM")]
    System,
    #[doc(alias = "VTE_CURSOR_BLINK_ON")]
    On,
    #[doc(alias = "VTE_CURSOR_BLINK_OFF")]
    Off,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CursorBlinkMode {
    type GlibType = ffi::VteCursorBlinkMode;

    #[inline]
fn into_glib(self) -> ffi::VteCursorBlinkMode {
match self {
            Self::System => ffi::VTE_CURSOR_BLINK_SYSTEM,
            Self::On => ffi::VTE_CURSOR_BLINK_ON,
            Self::Off => ffi::VTE_CURSOR_BLINK_OFF,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorBlinkMode> for CursorBlinkMode {
    #[inline]
unsafe fn from_glib(value: ffi::VteCursorBlinkMode) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_CURSOR_BLINK_SYSTEM => Self::System,
            ffi::VTE_CURSOR_BLINK_ON => Self::On,
            ffi::VTE_CURSOR_BLINK_OFF => Self::Off,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for CursorBlinkMode {
                #[inline]
    #[doc(alias = "vte_cursor_blink_mode_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_cursor_blink_mode_get_type()) }
                }
            }

impl glib::HasParamSpec for CursorBlinkMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for CursorBlinkMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorBlinkMode> for glib::Value {
    #[inline]
    fn from(v: CursorBlinkMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorShape")]
pub enum CursorShape {
    #[doc(alias = "VTE_CURSOR_SHAPE_BLOCK")]
    Block,
    #[doc(alias = "VTE_CURSOR_SHAPE_IBEAM")]
    Ibeam,
    #[doc(alias = "VTE_CURSOR_SHAPE_UNDERLINE")]
    Underline,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CursorShape {
    type GlibType = ffi::VteCursorShape;

    #[inline]
fn into_glib(self) -> ffi::VteCursorShape {
match self {
            Self::Block => ffi::VTE_CURSOR_SHAPE_BLOCK,
            Self::Ibeam => ffi::VTE_CURSOR_SHAPE_IBEAM,
            Self::Underline => ffi::VTE_CURSOR_SHAPE_UNDERLINE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorShape> for CursorShape {
    #[inline]
unsafe fn from_glib(value: ffi::VteCursorShape) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_CURSOR_SHAPE_BLOCK => Self::Block,
            ffi::VTE_CURSOR_SHAPE_IBEAM => Self::Ibeam,
            ffi::VTE_CURSOR_SHAPE_UNDERLINE => Self::Underline,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for CursorShape {
                #[inline]
    #[doc(alias = "vte_cursor_shape_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_cursor_shape_get_type()) }
                }
            }

impl glib::HasParamSpec for CursorShape {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for CursorShape {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorShape {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorShape {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorShape> for glib::Value {
    #[inline]
    fn from(v: CursorShape) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteEraseBinding")]
pub enum EraseBinding {
    #[doc(alias = "VTE_ERASE_AUTO")]
    Auto,
    #[doc(alias = "VTE_ERASE_ASCII_BACKSPACE")]
    AsciiBackspace,
    #[doc(alias = "VTE_ERASE_ASCII_DELETE")]
    AsciiDelete,
    #[doc(alias = "VTE_ERASE_DELETE_SEQUENCE")]
    DeleteSequence,
    #[doc(alias = "VTE_ERASE_TTY")]
    Tty,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EraseBinding {
    type GlibType = ffi::VteEraseBinding;

    #[inline]
fn into_glib(self) -> ffi::VteEraseBinding {
match self {
            Self::Auto => ffi::VTE_ERASE_AUTO,
            Self::AsciiBackspace => ffi::VTE_ERASE_ASCII_BACKSPACE,
            Self::AsciiDelete => ffi::VTE_ERASE_ASCII_DELETE,
            Self::DeleteSequence => ffi::VTE_ERASE_DELETE_SEQUENCE,
            Self::Tty => ffi::VTE_ERASE_TTY,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::VteEraseBinding> for EraseBinding {
    #[inline]
unsafe fn from_glib(value: ffi::VteEraseBinding) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_ERASE_AUTO => Self::Auto,
            ffi::VTE_ERASE_ASCII_BACKSPACE => Self::AsciiBackspace,
            ffi::VTE_ERASE_ASCII_DELETE => Self::AsciiDelete,
            ffi::VTE_ERASE_DELETE_SEQUENCE => Self::DeleteSequence,
            ffi::VTE_ERASE_TTY => Self::Tty,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for EraseBinding {
                #[inline]
    #[doc(alias = "vte_erase_binding_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_erase_binding_get_type()) }
                }
            }

impl glib::HasParamSpec for EraseBinding {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for EraseBinding {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EraseBinding {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EraseBinding {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EraseBinding> for glib::Value {
    #[inline]
    fn from(v: EraseBinding) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteFormat")]
pub enum Format {
    #[doc(alias = "VTE_FORMAT_TEXT")]
    Text,
    #[doc(alias = "VTE_FORMAT_HTML")]
    Html,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl IntoGlib for Format {
    type GlibType = ffi::VteFormat;

    #[inline]
fn into_glib(self) -> ffi::VteFormat {
match self {
            Self::Text => ffi::VTE_FORMAT_TEXT,
            Self::Html => ffi::VTE_FORMAT_HTML,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl FromGlib<ffi::VteFormat> for Format {
    #[inline]
unsafe fn from_glib(value: ffi::VteFormat) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_FORMAT_TEXT => Self::Text,
            ffi::VTE_FORMAT_HTML => Self::Html,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl StaticType for Format {
                #[inline]
    #[doc(alias = "vte_format_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_format_get_type()) }
                }
            }

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl glib::HasParamSpec for Format {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl glib::value::ValueType for Format {
    type Type = Self;
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
unsafe impl<'a> glib::value::FromValue<'a> for Format {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl ToValue for Format {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl From<Format> for glib::Value {
    #[inline]
    fn from(v: Format) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePtyError")]
pub enum PtyError {
    #[doc(alias = "VTE_PTY_ERROR_PTY_HELPER_FAILED")]
    PtyHelperFailed,
    #[doc(alias = "VTE_PTY_ERROR_PTY98_FAILED")]
    Pty98Failed,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PtyError {
    type GlibType = ffi::VtePtyError;

    #[inline]
fn into_glib(self) -> ffi::VtePtyError {
match self {
            Self::PtyHelperFailed => ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED,
            Self::Pty98Failed => ffi::VTE_PTY_ERROR_PTY98_FAILED,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::VtePtyError> for PtyError {
    #[inline]
unsafe fn from_glib(value: ffi::VtePtyError) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED => Self::PtyHelperFailed,
            ffi::VTE_PTY_ERROR_PTY98_FAILED => Self::Pty98Failed,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for PtyError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(ffi::vte_pty_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
}
    }
}

impl StaticType for PtyError {
                #[inline]
    #[doc(alias = "vte_pty_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_pty_error_get_type()) }
                }
            }

impl glib::HasParamSpec for PtyError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for PtyError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PtyError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PtyError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PtyError> for glib::Value {
    #[inline]
    fn from(v: PtyError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteRegexError")]
pub enum RegexError {
    #[doc(alias = "VTE_REGEX_ERROR_INCOMPATIBLE")]
    Incompatible,
    #[doc(alias = "VTE_REGEX_ERROR_NOT_SUPPORTED")]
    NotSupported,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[doc(hidden)]
impl IntoGlib for RegexError {
    type GlibType = ffi::VteRegexError;

    #[inline]
fn into_glib(self) -> ffi::VteRegexError {
match self {
            Self::Incompatible => ffi::VTE_REGEX_ERROR_INCOMPATIBLE,
            Self::NotSupported => ffi::VTE_REGEX_ERROR_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[doc(hidden)]
impl FromGlib<ffi::VteRegexError> for RegexError {
    #[inline]
unsafe fn from_glib(value: ffi::VteRegexError) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_REGEX_ERROR_INCOMPATIBLE => Self::Incompatible,
            ffi::VTE_REGEX_ERROR_NOT_SUPPORTED => Self::NotSupported,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::error::ErrorDomain for RegexError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(ffi::vte_regex_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
}
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl StaticType for RegexError {
                #[inline]
    #[doc(alias = "vte_regex_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_regex_error_get_type()) }
                }
            }

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::HasParamSpec for RegexError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::value::ValueType for RegexError {
    type Type = Self;
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for RegexError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl ToValue for RegexError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl From<RegexError> for glib::Value {
    #[inline]
    fn from(v: RegexError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteTextBlinkMode")]
pub enum TextBlinkMode {
    #[doc(alias = "VTE_TEXT_BLINK_NEVER")]
    Never,
    #[doc(alias = "VTE_TEXT_BLINK_FOCUSED")]
    Focused,
    #[doc(alias = "VTE_TEXT_BLINK_UNFOCUSED")]
    Unfocused,
    #[doc(alias = "VTE_TEXT_BLINK_ALWAYS")]
    Always,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl IntoGlib for TextBlinkMode {
    type GlibType = ffi::VteTextBlinkMode;

    #[inline]
fn into_glib(self) -> ffi::VteTextBlinkMode {
match self {
            Self::Never => ffi::VTE_TEXT_BLINK_NEVER,
            Self::Focused => ffi::VTE_TEXT_BLINK_FOCUSED,
            Self::Unfocused => ffi::VTE_TEXT_BLINK_UNFOCUSED,
            Self::Always => ffi::VTE_TEXT_BLINK_ALWAYS,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl FromGlib<ffi::VteTextBlinkMode> for TextBlinkMode {
    #[inline]
unsafe fn from_glib(value: ffi::VteTextBlinkMode) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_TEXT_BLINK_NEVER => Self::Never,
            ffi::VTE_TEXT_BLINK_FOCUSED => Self::Focused,
            ffi::VTE_TEXT_BLINK_UNFOCUSED => Self::Unfocused,
            ffi::VTE_TEXT_BLINK_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl StaticType for TextBlinkMode {
                #[inline]
    #[doc(alias = "vte_text_blink_mode_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_text_blink_mode_get_type()) }
                }
            }

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl glib::HasParamSpec for TextBlinkMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl glib::value::ValueType for TextBlinkMode {
    type Type = Self;
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for TextBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl ToValue for TextBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl From<TextBlinkMode> for glib::Value {
    #[inline]
    fn from(v: TextBlinkMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteWriteFlags")]
pub enum WriteFlags {
    #[doc(alias = "VTE_WRITE_DEFAULT")]
    Default,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WriteFlags {
    type GlibType = ffi::VteWriteFlags;

    #[inline]
fn into_glib(self) -> ffi::VteWriteFlags {
match self {
            Self::Default => ffi::VTE_WRITE_DEFAULT,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::VteWriteFlags> for WriteFlags {
    #[inline]
unsafe fn from_glib(value: ffi::VteWriteFlags) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::VTE_WRITE_DEFAULT => Self::Default,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for WriteFlags {
                #[inline]
    #[doc(alias = "vte_write_flags_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::vte_write_flags_get_type()) }
                }
            }

impl glib::HasParamSpec for WriteFlags {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for WriteFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WriteFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WriteFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WriteFlags> for glib::Value {
    #[inline]
    fn from(v: WriteFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

