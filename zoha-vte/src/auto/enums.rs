// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /home/milan/git/zoha-vte-rs/gir-files
// from /home/milan/git/zoha-vte-rs/vte/share/gir-1.0
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteAlign")]
pub enum Align {
    #[doc(alias = "VTE_ALIGN_START")]
    Start,
    #[doc(alias = "VTE_ALIGN_CENTER")]
    Center,
    #[doc(alias = "VTE_ALIGN_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Align {
    type GlibType = ffi::VteAlign;

    #[inline]
    fn into_glib(self) -> ffi::VteAlign {
        match self {
            Self::Start => ffi::VTE_ALIGN_START,
            Self::Center => ffi::VTE_ALIGN_CENTER,
            Self::End => ffi::VTE_ALIGN_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteAlign> for Align {
    #[inline]
    unsafe fn from_glib(value: ffi::VteAlign) -> Self {
        match value {
            ffi::VTE_ALIGN_START => Self::Start,
            ffi::VTE_ALIGN_CENTER => Self::Center,
            ffi::VTE_ALIGN_END => Self::End,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Align {
    #[inline]
    #[doc(alias = "vte_align_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_align_get_type()) }
    }
}

impl glib::HasParamSpec for Align {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Align {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Align {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for Align {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Align> for glib::Value {
    #[inline]
    fn from(v: Align) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorBlinkMode")]
pub enum CursorBlinkMode {
    #[doc(alias = "VTE_CURSOR_BLINK_SYSTEM")]
    System,
    #[doc(alias = "VTE_CURSOR_BLINK_ON")]
    On,
    #[doc(alias = "VTE_CURSOR_BLINK_OFF")]
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CursorBlinkMode {
    type GlibType = ffi::VteCursorBlinkMode;

    #[inline]
    fn into_glib(self) -> ffi::VteCursorBlinkMode {
        match self {
            Self::System => ffi::VTE_CURSOR_BLINK_SYSTEM,
            Self::On => ffi::VTE_CURSOR_BLINK_ON,
            Self::Off => ffi::VTE_CURSOR_BLINK_OFF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorBlinkMode> for CursorBlinkMode {
    #[inline]
    unsafe fn from_glib(value: ffi::VteCursorBlinkMode) -> Self {
        match value {
            ffi::VTE_CURSOR_BLINK_SYSTEM => Self::System,
            ffi::VTE_CURSOR_BLINK_ON => Self::On,
            ffi::VTE_CURSOR_BLINK_OFF => Self::Off,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CursorBlinkMode {
    #[inline]
    #[doc(alias = "vte_cursor_blink_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_cursor_blink_mode_get_type()) }
    }
}

impl glib::HasParamSpec for CursorBlinkMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CursorBlinkMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for CursorBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorBlinkMode> for glib::Value {
    #[inline]
    fn from(v: CursorBlinkMode) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorShape")]
pub enum CursorShape {
    #[doc(alias = "VTE_CURSOR_SHAPE_BLOCK")]
    Block,
    #[doc(alias = "VTE_CURSOR_SHAPE_IBEAM")]
    Ibeam,
    #[doc(alias = "VTE_CURSOR_SHAPE_UNDERLINE")]
    Underline,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CursorShape {
    type GlibType = ffi::VteCursorShape;

    #[inline]
    fn into_glib(self) -> ffi::VteCursorShape {
        match self {
            Self::Block => ffi::VTE_CURSOR_SHAPE_BLOCK,
            Self::Ibeam => ffi::VTE_CURSOR_SHAPE_IBEAM,
            Self::Underline => ffi::VTE_CURSOR_SHAPE_UNDERLINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorShape> for CursorShape {
    #[inline]
    unsafe fn from_glib(value: ffi::VteCursorShape) -> Self {
        match value {
            ffi::VTE_CURSOR_SHAPE_BLOCK => Self::Block,
            ffi::VTE_CURSOR_SHAPE_IBEAM => Self::Ibeam,
            ffi::VTE_CURSOR_SHAPE_UNDERLINE => Self::Underline,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CursorShape {
    #[inline]
    #[doc(alias = "vte_cursor_shape_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_cursor_shape_get_type()) }
    }
}

impl glib::HasParamSpec for CursorShape {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for CursorShape {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorShape {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for CursorShape {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorShape> for glib::Value {
    #[inline]
    fn from(v: CursorShape) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteEraseBinding")]
pub enum EraseBinding {
    #[doc(alias = "VTE_ERASE_AUTO")]
    Auto,
    #[doc(alias = "VTE_ERASE_ASCII_BACKSPACE")]
    AsciiBackspace,
    #[doc(alias = "VTE_ERASE_ASCII_DELETE")]
    AsciiDelete,
    #[doc(alias = "VTE_ERASE_DELETE_SEQUENCE")]
    DeleteSequence,
    #[doc(alias = "VTE_ERASE_TTY")]
    Tty,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for EraseBinding {
    type GlibType = ffi::VteEraseBinding;

    #[inline]
    fn into_glib(self) -> ffi::VteEraseBinding {
        match self {
            Self::Auto => ffi::VTE_ERASE_AUTO,
            Self::AsciiBackspace => ffi::VTE_ERASE_ASCII_BACKSPACE,
            Self::AsciiDelete => ffi::VTE_ERASE_ASCII_DELETE,
            Self::DeleteSequence => ffi::VTE_ERASE_DELETE_SEQUENCE,
            Self::Tty => ffi::VTE_ERASE_TTY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteEraseBinding> for EraseBinding {
    #[inline]
    unsafe fn from_glib(value: ffi::VteEraseBinding) -> Self {
        match value {
            ffi::VTE_ERASE_AUTO => Self::Auto,
            ffi::VTE_ERASE_ASCII_BACKSPACE => Self::AsciiBackspace,
            ffi::VTE_ERASE_ASCII_DELETE => Self::AsciiDelete,
            ffi::VTE_ERASE_DELETE_SEQUENCE => Self::DeleteSequence,
            ffi::VTE_ERASE_TTY => Self::Tty,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EraseBinding {
    #[inline]
    #[doc(alias = "vte_erase_binding_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_erase_binding_get_type()) }
    }
}

impl glib::HasParamSpec for EraseBinding {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for EraseBinding {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EraseBinding {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for EraseBinding {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EraseBinding> for glib::Value {
    #[inline]
    fn from(v: EraseBinding) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteFormat")]
pub enum Format {
    #[doc(alias = "VTE_FORMAT_TEXT")]
    Text,
    #[doc(alias = "VTE_FORMAT_HTML")]
    Html,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Format {
    type GlibType = ffi::VteFormat;

    #[inline]
    fn into_glib(self) -> ffi::VteFormat {
        match self {
            Self::Text => ffi::VTE_FORMAT_TEXT,
            Self::Html => ffi::VTE_FORMAT_HTML,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteFormat> for Format {
    #[inline]
    unsafe fn from_glib(value: ffi::VteFormat) -> Self {
        match value {
            ffi::VTE_FORMAT_TEXT => Self::Text,
            ffi::VTE_FORMAT_HTML => Self::Html,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for Format {
    #[inline]
    #[doc(alias = "vte_format_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_format_get_type()) }
    }
}

impl glib::HasParamSpec for Format {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for Format {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Format {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for Format {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Format> for glib::Value {
    #[inline]
    fn from(v: Format) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteProgressHint")]
pub enum ProgressHint {
    #[doc(alias = "VTE_PROGRESS_HINT_INACTIVE")]
    Inactive,
    #[doc(alias = "VTE_PROGRESS_HINT_ACTIVE")]
    Active,
    #[doc(alias = "VTE_PROGRESS_HINT_ERROR")]
    Error,
    #[doc(alias = "VTE_PROGRESS_HINT_INDETERMINATE")]
    Indeterminate,
    #[doc(alias = "VTE_PROGRESS_HINT_PAUSED")]
    Paused,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ProgressHint {
    type GlibType = ffi::VteProgressHint;

    #[inline]
    fn into_glib(self) -> ffi::VteProgressHint {
        match self {
            Self::Inactive => ffi::VTE_PROGRESS_HINT_INACTIVE,
            Self::Active => ffi::VTE_PROGRESS_HINT_ACTIVE,
            Self::Error => ffi::VTE_PROGRESS_HINT_ERROR,
            Self::Indeterminate => ffi::VTE_PROGRESS_HINT_INDETERMINATE,
            Self::Paused => ffi::VTE_PROGRESS_HINT_PAUSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteProgressHint> for ProgressHint {
    #[inline]
    unsafe fn from_glib(value: ffi::VteProgressHint) -> Self {
        match value {
            ffi::VTE_PROGRESS_HINT_INACTIVE => Self::Inactive,
            ffi::VTE_PROGRESS_HINT_ACTIVE => Self::Active,
            ffi::VTE_PROGRESS_HINT_ERROR => Self::Error,
            ffi::VTE_PROGRESS_HINT_INDETERMINATE => Self::Indeterminate,
            ffi::VTE_PROGRESS_HINT_PAUSED => Self::Paused,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ProgressHint {
    #[inline]
    #[doc(alias = "vte_progress_hint_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_progress_hint_get_type()) }
    }
}

impl glib::HasParamSpec for ProgressHint {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for ProgressHint {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ProgressHint {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for ProgressHint {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ProgressHint> for glib::Value {
    #[inline]
    fn from(v: ProgressHint) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePropertyId")]
pub enum PropertyId {
    #[doc(alias = "VTE_PROPERTY_ID_CURRENT_DIRECTORY_URI")]
    CurrentDirectoryUri,
    #[doc(alias = "VTE_PROPERTY_ID_CURRENT_FILE_URI")]
    CurrentFileUri,
    #[doc(alias = "VTE_PROPERTY_ID_XTERM_TITLE")]
    XtermTitle,
    #[doc(alias = "VTE_PROPERTY_ID_CONTAINER_NAME")]
    ContainerName,
    #[doc(alias = "VTE_PROPERTY_ID_CONTAINER_RUNTIME")]
    ContainerRuntime,
    #[doc(alias = "VTE_PROPERTY_ID_CONTAINER_UID")]
    ContainerUid,
    #[doc(alias = "VTE_PROPERTY_ID_SHELL_PRECMD")]
    ShellPrecmd,
    #[doc(alias = "VTE_PROPERTY_ID_SHELL_PREEXEC")]
    ShellPreexec,
    #[doc(alias = "VTE_PROPERTY_ID_SHELL_POSTEXEC")]
    ShellPostexec,
    #[doc(alias = "VTE_PROPERTY_ID_PROGRESS_HINT")]
    ProgressHint,
    #[doc(alias = "VTE_PROPERTY_ID_PROGRESS_VALUE")]
    ProgressValue,
    #[doc(alias = "VTE_PROPERTY_ID_ICON_COLOR")]
    IconColor,
    #[doc(alias = "VTE_PROPERTY_ID_ICON_IMAGE")]
    IconImage,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PropertyId {
    type GlibType = ffi::VtePropertyId;

    fn into_glib(self) -> ffi::VtePropertyId {
        match self {
            Self::CurrentDirectoryUri => ffi::VTE_PROPERTY_ID_CURRENT_DIRECTORY_URI,
            Self::CurrentFileUri => ffi::VTE_PROPERTY_ID_CURRENT_FILE_URI,
            Self::XtermTitle => ffi::VTE_PROPERTY_ID_XTERM_TITLE,
            Self::ContainerName => ffi::VTE_PROPERTY_ID_CONTAINER_NAME,
            Self::ContainerRuntime => ffi::VTE_PROPERTY_ID_CONTAINER_RUNTIME,
            Self::ContainerUid => ffi::VTE_PROPERTY_ID_CONTAINER_UID,
            Self::ShellPrecmd => ffi::VTE_PROPERTY_ID_SHELL_PRECMD,
            Self::ShellPreexec => ffi::VTE_PROPERTY_ID_SHELL_PREEXEC,
            Self::ShellPostexec => ffi::VTE_PROPERTY_ID_SHELL_POSTEXEC,
            Self::ProgressHint => ffi::VTE_PROPERTY_ID_PROGRESS_HINT,
            Self::ProgressValue => ffi::VTE_PROPERTY_ID_PROGRESS_VALUE,
            Self::IconColor => ffi::VTE_PROPERTY_ID_ICON_COLOR,
            Self::IconImage => ffi::VTE_PROPERTY_ID_ICON_IMAGE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VtePropertyId> for PropertyId {
    unsafe fn from_glib(value: ffi::VtePropertyId) -> Self {
        match value {
            ffi::VTE_PROPERTY_ID_CURRENT_DIRECTORY_URI => Self::CurrentDirectoryUri,
            ffi::VTE_PROPERTY_ID_CURRENT_FILE_URI => Self::CurrentFileUri,
            ffi::VTE_PROPERTY_ID_XTERM_TITLE => Self::XtermTitle,
            ffi::VTE_PROPERTY_ID_CONTAINER_NAME => Self::ContainerName,
            ffi::VTE_PROPERTY_ID_CONTAINER_RUNTIME => Self::ContainerRuntime,
            ffi::VTE_PROPERTY_ID_CONTAINER_UID => Self::ContainerUid,
            ffi::VTE_PROPERTY_ID_SHELL_PRECMD => Self::ShellPrecmd,
            ffi::VTE_PROPERTY_ID_SHELL_PREEXEC => Self::ShellPreexec,
            ffi::VTE_PROPERTY_ID_SHELL_POSTEXEC => Self::ShellPostexec,
            ffi::VTE_PROPERTY_ID_PROGRESS_HINT => Self::ProgressHint,
            ffi::VTE_PROPERTY_ID_PROGRESS_VALUE => Self::ProgressValue,
            ffi::VTE_PROPERTY_ID_ICON_COLOR => Self::IconColor,
            ffi::VTE_PROPERTY_ID_ICON_IMAGE => Self::IconImage,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PropertyId {
    #[inline]
    #[doc(alias = "vte_property_id_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_property_id_get_type()) }
    }
}

impl glib::HasParamSpec for PropertyId {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PropertyId {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PropertyId {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for PropertyId {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PropertyId> for glib::Value {
    #[inline]
    fn from(v: PropertyId) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePropertyType")]
pub enum PropertyType {
    #[doc(alias = "VTE_PROPERTY_VALUELESS")]
    Valueless,
    #[doc(alias = "VTE_PROPERTY_BOOL")]
    Bool,
    #[doc(alias = "VTE_PROPERTY_INT")]
    Int,
    #[doc(alias = "VTE_PROPERTY_UINT")]
    Uint,
    #[doc(alias = "VTE_PROPERTY_DOUBLE")]
    Double,
    #[doc(alias = "VTE_PROPERTY_RGB")]
    Rgb,
    #[doc(alias = "VTE_PROPERTY_RGBA")]
    Rgba,
    #[doc(alias = "VTE_PROPERTY_STRING")]
    String,
    #[doc(alias = "VTE_PROPERTY_DATA")]
    Data,
    #[doc(alias = "VTE_PROPERTY_UUID")]
    Uuid,
    #[doc(alias = "VTE_PROPERTY_URI")]
    Uri,
    #[doc(alias = "VTE_PROPERTY_IMAGE")]
    Image,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PropertyType {
    type GlibType = ffi::VtePropertyType;

    #[inline]
    fn into_glib(self) -> ffi::VtePropertyType {
        match self {
            Self::Valueless => ffi::VTE_PROPERTY_VALUELESS,
            Self::Bool => ffi::VTE_PROPERTY_BOOL,
            Self::Int => ffi::VTE_PROPERTY_INT,
            Self::Uint => ffi::VTE_PROPERTY_UINT,
            Self::Double => ffi::VTE_PROPERTY_DOUBLE,
            Self::Rgb => ffi::VTE_PROPERTY_RGB,
            Self::Rgba => ffi::VTE_PROPERTY_RGBA,
            Self::String => ffi::VTE_PROPERTY_STRING,
            Self::Data => ffi::VTE_PROPERTY_DATA,
            Self::Uuid => ffi::VTE_PROPERTY_UUID,
            Self::Uri => ffi::VTE_PROPERTY_URI,
            Self::Image => ffi::VTE_PROPERTY_IMAGE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VtePropertyType> for PropertyType {
    #[inline]
    unsafe fn from_glib(value: ffi::VtePropertyType) -> Self {
        match value {
            ffi::VTE_PROPERTY_VALUELESS => Self::Valueless,
            ffi::VTE_PROPERTY_BOOL => Self::Bool,
            ffi::VTE_PROPERTY_INT => Self::Int,
            ffi::VTE_PROPERTY_UINT => Self::Uint,
            ffi::VTE_PROPERTY_DOUBLE => Self::Double,
            ffi::VTE_PROPERTY_RGB => Self::Rgb,
            ffi::VTE_PROPERTY_RGBA => Self::Rgba,
            ffi::VTE_PROPERTY_STRING => Self::String,
            ffi::VTE_PROPERTY_DATA => Self::Data,
            ffi::VTE_PROPERTY_UUID => Self::Uuid,
            ffi::VTE_PROPERTY_URI => Self::Uri,
            ffi::VTE_PROPERTY_IMAGE => Self::Image,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for PropertyType {
    #[inline]
    #[doc(alias = "vte_property_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_property_type_get_type()) }
    }
}

impl glib::HasParamSpec for PropertyType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PropertyType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PropertyType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for PropertyType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PropertyType> for glib::Value {
    #[inline]
    fn from(v: PropertyType) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePtyError")]
pub enum PtyError {
    #[doc(alias = "VTE_PTY_ERROR_PTY_HELPER_FAILED")]
    PtyHelperFailed,
    #[doc(alias = "VTE_PTY_ERROR_PTY98_FAILED")]
    Pty98Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PtyError {
    type GlibType = ffi::VtePtyError;

    #[inline]
    fn into_glib(self) -> ffi::VtePtyError {
        match self {
            Self::PtyHelperFailed => ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED,
            Self::Pty98Failed => ffi::VTE_PTY_ERROR_PTY98_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VtePtyError> for PtyError {
    #[inline]
    unsafe fn from_glib(value: ffi::VtePtyError) -> Self {
        match value {
            ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED => Self::PtyHelperFailed,
            ffi::VTE_PTY_ERROR_PTY98_FAILED => Self::Pty98Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for PtyError {
    #[inline]
    fn domain() -> glib::Quark {
        unsafe { from_glib(ffi::vte_pty_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for PtyError {
    #[inline]
    #[doc(alias = "vte_pty_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_pty_error_get_type()) }
    }
}

impl glib::HasParamSpec for PtyError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for PtyError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PtyError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for PtyError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PtyError> for glib::Value {
    #[inline]
    fn from(v: PtyError) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteRegexError")]
pub enum RegexError {
    #[doc(alias = "VTE_REGEX_ERROR_INCOMPATIBLE")]
    Incompatible,
    #[doc(alias = "VTE_REGEX_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RegexError {
    type GlibType = ffi::VteRegexError;

    #[inline]
    fn into_glib(self) -> ffi::VteRegexError {
        match self {
            Self::Incompatible => ffi::VTE_REGEX_ERROR_INCOMPATIBLE,
            Self::NotSupported => ffi::VTE_REGEX_ERROR_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteRegexError> for RegexError {
    #[inline]
    unsafe fn from_glib(value: ffi::VteRegexError) -> Self {
        match value {
            ffi::VTE_REGEX_ERROR_INCOMPATIBLE => Self::Incompatible,
            ffi::VTE_REGEX_ERROR_NOT_SUPPORTED => Self::NotSupported,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for RegexError {
    #[inline]
    fn domain() -> glib::Quark {
        unsafe { from_glib(ffi::vte_regex_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

impl StaticType for RegexError {
    #[inline]
    #[doc(alias = "vte_regex_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_regex_error_get_type()) }
    }
}

impl glib::HasParamSpec for RegexError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for RegexError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RegexError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for RegexError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RegexError> for glib::Value {
    #[inline]
    fn from(v: RegexError) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteSystemdContextExitCondition")]
pub enum SystemdContextExitCondition {
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_SUCCESS")]
    Success,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_CRASH")]
    Crash,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_FAILURE")]
    Failure,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_INTERRUPT")]
    Interrupt,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SystemdContextExitCondition {
    type GlibType = ffi::VteSystemdContextExitCondition;

    #[inline]
    fn into_glib(self) -> ffi::VteSystemdContextExitCondition {
        match self {
            Self::Success => ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_SUCCESS,
            Self::Crash => ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_CRASH,
            Self::Failure => ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_FAILURE,
            Self::Interrupt => ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_INTERRUPT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteSystemdContextExitCondition> for SystemdContextExitCondition {
    #[inline]
    unsafe fn from_glib(value: ffi::VteSystemdContextExitCondition) -> Self {
        match value {
            ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_SUCCESS => Self::Success,
            ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_CRASH => Self::Crash,
            ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_FAILURE => Self::Failure,
            ffi::VTE_SYSTEMD_CONTEXT_EXIT_CONDITION_INTERRUPT => Self::Interrupt,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SystemdContextExitCondition {
    #[inline]
    #[doc(alias = "vte_systemd_context_exit_condition_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_systemd_context_exit_condition_get_type()) }
    }
}

impl glib::HasParamSpec for SystemdContextExitCondition {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SystemdContextExitCondition {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SystemdContextExitCondition {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for SystemdContextExitCondition {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SystemdContextExitCondition> for glib::Value {
    #[inline]
    fn from(v: SystemdContextExitCondition) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteSystemdContextOperation")]
pub enum SystemdContextOperation {
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_OPERATION_START")]
    Start,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_OPERATION_END")]
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SystemdContextOperation {
    type GlibType = ffi::VteSystemdContextOperation;

    #[inline]
    fn into_glib(self) -> ffi::VteSystemdContextOperation {
        match self {
            Self::Start => ffi::VTE_SYSTEMD_CONTEXT_OPERATION_START,
            Self::End => ffi::VTE_SYSTEMD_CONTEXT_OPERATION_END,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteSystemdContextOperation> for SystemdContextOperation {
    #[inline]
    unsafe fn from_glib(value: ffi::VteSystemdContextOperation) -> Self {
        match value {
            ffi::VTE_SYSTEMD_CONTEXT_OPERATION_START => Self::Start,
            ffi::VTE_SYSTEMD_CONTEXT_OPERATION_END => Self::End,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SystemdContextOperation {
    #[inline]
    #[doc(alias = "vte_systemd_context_operation_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_systemd_context_operation_get_type()) }
    }
}

impl glib::HasParamSpec for SystemdContextOperation {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SystemdContextOperation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SystemdContextOperation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for SystemdContextOperation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SystemdContextOperation> for glib::Value {
    #[inline]
    fn from(v: SystemdContextOperation) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteSystemdContextType")]
pub enum SystemdContextType {
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_BUILTIN")]
    Builtin,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_APP")]
    App,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_BOOT")]
    Boot,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_CHPRIV")]
    Chpriv,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_COMMAND")]
    Command,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_CONTAINER")]
    Container,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_ELEVATE")]
    Elevate,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_REMOTE")]
    Remote,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_SERVICE")]
    Service,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_SESSION")]
    Session,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_SHELL")]
    Shell,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_SUBCONTEXT")]
    Subcontext,
    #[doc(alias = "VTE_SYSTEMD_CONTEXT_TYPE_VM")]
    Vm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SystemdContextType {
    type GlibType = ffi::VteSystemdContextType;

    fn into_glib(self) -> ffi::VteSystemdContextType {
        match self {
            Self::Builtin => ffi::VTE_SYSTEMD_CONTEXT_TYPE_BUILTIN,
            Self::App => ffi::VTE_SYSTEMD_CONTEXT_TYPE_APP,
            Self::Boot => ffi::VTE_SYSTEMD_CONTEXT_TYPE_BOOT,
            Self::Chpriv => ffi::VTE_SYSTEMD_CONTEXT_TYPE_CHPRIV,
            Self::Command => ffi::VTE_SYSTEMD_CONTEXT_TYPE_COMMAND,
            Self::Container => ffi::VTE_SYSTEMD_CONTEXT_TYPE_CONTAINER,
            Self::Elevate => ffi::VTE_SYSTEMD_CONTEXT_TYPE_ELEVATE,
            Self::Remote => ffi::VTE_SYSTEMD_CONTEXT_TYPE_REMOTE,
            Self::Service => ffi::VTE_SYSTEMD_CONTEXT_TYPE_SERVICE,
            Self::Session => ffi::VTE_SYSTEMD_CONTEXT_TYPE_SESSION,
            Self::Shell => ffi::VTE_SYSTEMD_CONTEXT_TYPE_SHELL,
            Self::Subcontext => ffi::VTE_SYSTEMD_CONTEXT_TYPE_SUBCONTEXT,
            Self::Vm => ffi::VTE_SYSTEMD_CONTEXT_TYPE_VM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteSystemdContextType> for SystemdContextType {
    unsafe fn from_glib(value: ffi::VteSystemdContextType) -> Self {
        match value {
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_BUILTIN => Self::Builtin,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_APP => Self::App,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_BOOT => Self::Boot,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_CHPRIV => Self::Chpriv,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_COMMAND => Self::Command,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_CONTAINER => Self::Container,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_ELEVATE => Self::Elevate,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_REMOTE => Self::Remote,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_SERVICE => Self::Service,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_SESSION => Self::Session,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_SHELL => Self::Shell,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_SUBCONTEXT => Self::Subcontext,
            ffi::VTE_SYSTEMD_CONTEXT_TYPE_VM => Self::Vm,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SystemdContextType {
    #[inline]
    #[doc(alias = "vte_systemd_context_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_systemd_context_type_get_type()) }
    }
}

impl glib::HasParamSpec for SystemdContextType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SystemdContextType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SystemdContextType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for SystemdContextType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SystemdContextType> for glib::Value {
    #[inline]
    fn from(v: SystemdContextType) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteSystemdPropertyId")]
pub enum SystemdPropertyId {
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_CONTEXT_ID")]
    ContextId,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_BOOT_ID")]
    BootId,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_COMM")]
    Comm,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_COMMAND_LINE")]
    CommandLine,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_CONTAINER")]
    Container,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_CONTEXT_TYPE")]
    ContextType,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_CURRENT_DIRECTORY")]
    CurrentDirectory,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_EXIT_CONDITION")]
    ExitCondition,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_EXIT_SIGNAL")]
    ExitSignal,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_EXIT_STATUS")]
    ExitStatus,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_HOSTNAME")]
    Hostname,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_MACHINE_ID")]
    MachineId,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_PID")]
    Pid,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_PIDFD_INODE")]
    PidfdInode,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_TARGET_HOST")]
    TargetHost,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_TARGET_USER")]
    TargetUser,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_USER")]
    User,
    #[doc(alias = "VTE_SYSTEMD_PROPERTY_ID_VM")]
    Vm,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SystemdPropertyId {
    type GlibType = ffi::VteSystemdPropertyId;

    fn into_glib(self) -> ffi::VteSystemdPropertyId {
        match self {
            Self::ContextId => ffi::VTE_SYSTEMD_PROPERTY_ID_CONTEXT_ID,
            Self::BootId => ffi::VTE_SYSTEMD_PROPERTY_ID_BOOT_ID,
            Self::Comm => ffi::VTE_SYSTEMD_PROPERTY_ID_COMM,
            Self::CommandLine => ffi::VTE_SYSTEMD_PROPERTY_ID_COMMAND_LINE,
            Self::Container => ffi::VTE_SYSTEMD_PROPERTY_ID_CONTAINER,
            Self::ContextType => ffi::VTE_SYSTEMD_PROPERTY_ID_CONTEXT_TYPE,
            Self::CurrentDirectory => ffi::VTE_SYSTEMD_PROPERTY_ID_CURRENT_DIRECTORY,
            Self::ExitCondition => ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_CONDITION,
            Self::ExitSignal => ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_SIGNAL,
            Self::ExitStatus => ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_STATUS,
            Self::Hostname => ffi::VTE_SYSTEMD_PROPERTY_ID_HOSTNAME,
            Self::MachineId => ffi::VTE_SYSTEMD_PROPERTY_ID_MACHINE_ID,
            Self::Pid => ffi::VTE_SYSTEMD_PROPERTY_ID_PID,
            Self::PidfdInode => ffi::VTE_SYSTEMD_PROPERTY_ID_PIDFD_INODE,
            Self::TargetHost => ffi::VTE_SYSTEMD_PROPERTY_ID_TARGET_HOST,
            Self::TargetUser => ffi::VTE_SYSTEMD_PROPERTY_ID_TARGET_USER,
            Self::User => ffi::VTE_SYSTEMD_PROPERTY_ID_USER,
            Self::Vm => ffi::VTE_SYSTEMD_PROPERTY_ID_VM,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteSystemdPropertyId> for SystemdPropertyId {
    unsafe fn from_glib(value: ffi::VteSystemdPropertyId) -> Self {
        match value {
            ffi::VTE_SYSTEMD_PROPERTY_ID_CONTEXT_ID => Self::ContextId,
            ffi::VTE_SYSTEMD_PROPERTY_ID_BOOT_ID => Self::BootId,
            ffi::VTE_SYSTEMD_PROPERTY_ID_COMM => Self::Comm,
            ffi::VTE_SYSTEMD_PROPERTY_ID_COMMAND_LINE => Self::CommandLine,
            ffi::VTE_SYSTEMD_PROPERTY_ID_CONTAINER => Self::Container,
            ffi::VTE_SYSTEMD_PROPERTY_ID_CONTEXT_TYPE => Self::ContextType,
            ffi::VTE_SYSTEMD_PROPERTY_ID_CURRENT_DIRECTORY => Self::CurrentDirectory,
            ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_CONDITION => Self::ExitCondition,
            ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_SIGNAL => Self::ExitSignal,
            ffi::VTE_SYSTEMD_PROPERTY_ID_EXIT_STATUS => Self::ExitStatus,
            ffi::VTE_SYSTEMD_PROPERTY_ID_HOSTNAME => Self::Hostname,
            ffi::VTE_SYSTEMD_PROPERTY_ID_MACHINE_ID => Self::MachineId,
            ffi::VTE_SYSTEMD_PROPERTY_ID_PID => Self::Pid,
            ffi::VTE_SYSTEMD_PROPERTY_ID_PIDFD_INODE => Self::PidfdInode,
            ffi::VTE_SYSTEMD_PROPERTY_ID_TARGET_HOST => Self::TargetHost,
            ffi::VTE_SYSTEMD_PROPERTY_ID_TARGET_USER => Self::TargetUser,
            ffi::VTE_SYSTEMD_PROPERTY_ID_USER => Self::User,
            ffi::VTE_SYSTEMD_PROPERTY_ID_VM => Self::Vm,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SystemdPropertyId {
    #[inline]
    #[doc(alias = "vte_systemd_property_id_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_systemd_property_id_get_type()) }
    }
}

impl glib::HasParamSpec for SystemdPropertyId {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SystemdPropertyId {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SystemdPropertyId {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for SystemdPropertyId {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SystemdPropertyId> for glib::Value {
    #[inline]
    fn from(v: SystemdPropertyId) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteTextBlinkMode")]
pub enum TextBlinkMode {
    #[doc(alias = "VTE_TEXT_BLINK_NEVER")]
    Never,
    #[doc(alias = "VTE_TEXT_BLINK_FOCUSED")]
    Focused,
    #[doc(alias = "VTE_TEXT_BLINK_UNFOCUSED")]
    Unfocused,
    #[doc(alias = "VTE_TEXT_BLINK_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TextBlinkMode {
    type GlibType = ffi::VteTextBlinkMode;

    #[inline]
    fn into_glib(self) -> ffi::VteTextBlinkMode {
        match self {
            Self::Never => ffi::VTE_TEXT_BLINK_NEVER,
            Self::Focused => ffi::VTE_TEXT_BLINK_FOCUSED,
            Self::Unfocused => ffi::VTE_TEXT_BLINK_UNFOCUSED,
            Self::Always => ffi::VTE_TEXT_BLINK_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteTextBlinkMode> for TextBlinkMode {
    #[inline]
    unsafe fn from_glib(value: ffi::VteTextBlinkMode) -> Self {
        match value {
            ffi::VTE_TEXT_BLINK_NEVER => Self::Never,
            ffi::VTE_TEXT_BLINK_FOCUSED => Self::Focused,
            ffi::VTE_TEXT_BLINK_UNFOCUSED => Self::Unfocused,
            ffi::VTE_TEXT_BLINK_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for TextBlinkMode {
    #[inline]
    #[doc(alias = "vte_text_blink_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_text_blink_mode_get_type()) }
    }
}

impl glib::HasParamSpec for TextBlinkMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for TextBlinkMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TextBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for TextBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TextBlinkMode> for glib::Value {
    #[inline]
    fn from(v: TextBlinkMode) -> Self {
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteWriteFlags")]
pub enum WriteFlags {
    #[doc(alias = "VTE_WRITE_DEFAULT")]
    Default,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WriteFlags {
    type GlibType = ffi::VteWriteFlags;

    #[inline]
    fn into_glib(self) -> ffi::VteWriteFlags {
        match self {
            Self::Default => ffi::VTE_WRITE_DEFAULT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteWriteFlags> for WriteFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::VteWriteFlags) -> Self {
        match value {
            ffi::VTE_WRITE_DEFAULT => Self::Default,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WriteFlags {
    #[inline]
    #[doc(alias = "vte_write_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::vte_write_flags_get_type()) }
    }
}

impl glib::HasParamSpec for WriteFlags {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WriteFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WriteFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for WriteFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WriteFlags> for glib::Value {
    #[inline]
    fn from(v: WriteFlags) -> Self {
        ToValue::to_value(&v)
    }
}
