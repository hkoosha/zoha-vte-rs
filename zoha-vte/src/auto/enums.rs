// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,translate::*};
use std::{fmt};
use zoha_vte_sys::*;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorBlinkMode")]
pub enum CursorBlinkMode {
    #[doc(alias = "VTE_CURSOR_BLINK_SYSTEM")]
    System,
    #[doc(alias = "VTE_CURSOR_BLINK_ON")]
    On,
    #[doc(alias = "VTE_CURSOR_BLINK_OFF")]
    Off,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CursorBlinkMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CursorBlinkMode::{}", match *self {
            Self::System => "System",
            Self::On => "On",
            Self::Off => "Off",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CursorBlinkMode {
    type GlibType = VteCursorBlinkMode;

    #[inline]
fn into_glib(self) -> VteCursorBlinkMode {
match self {
            Self::System => VTE_CURSOR_BLINK_SYSTEM,
            Self::On => VTE_CURSOR_BLINK_ON,
            Self::Off => VTE_CURSOR_BLINK_OFF,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<VteCursorBlinkMode> for CursorBlinkMode {
    #[inline]
unsafe fn from_glib(value: VteCursorBlinkMode) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_CURSOR_BLINK_SYSTEM => Self::System,
            VTE_CURSOR_BLINK_ON => Self::On,
            VTE_CURSOR_BLINK_OFF => Self::Off,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for CursorBlinkMode {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_cursor_blink_mode_get_type()) }
    }
}

impl glib::HasParamSpec for CursorBlinkMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

impl glib::value::ValueType for CursorBlinkMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorBlinkMode> for glib::Value {
    #[inline]
    fn from(v: CursorBlinkMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorShape")]
pub enum CursorShape {
    #[doc(alias = "VTE_CURSOR_SHAPE_BLOCK")]
    Block,
    #[doc(alias = "VTE_CURSOR_SHAPE_IBEAM")]
    Ibeam,
    #[doc(alias = "VTE_CURSOR_SHAPE_UNDERLINE")]
    Underline,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CursorShape {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CursorShape::{}", match *self {
            Self::Block => "Block",
            Self::Ibeam => "Ibeam",
            Self::Underline => "Underline",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CursorShape {
    type GlibType = VteCursorShape;

    #[inline]
fn into_glib(self) -> VteCursorShape {
match self {
            Self::Block => VTE_CURSOR_SHAPE_BLOCK,
            Self::Ibeam => VTE_CURSOR_SHAPE_IBEAM,
            Self::Underline => VTE_CURSOR_SHAPE_UNDERLINE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<VteCursorShape> for CursorShape {
    #[inline]
unsafe fn from_glib(value: VteCursorShape) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_CURSOR_SHAPE_BLOCK => Self::Block,
            VTE_CURSOR_SHAPE_IBEAM => Self::Ibeam,
            VTE_CURSOR_SHAPE_UNDERLINE => Self::Underline,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for CursorShape {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_cursor_shape_get_type()) }
    }
}

impl glib::HasParamSpec for CursorShape {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

impl glib::value::ValueType for CursorShape {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CursorShape {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorShape {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CursorShape> for glib::Value {
    #[inline]
    fn from(v: CursorShape) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteEraseBinding")]
pub enum EraseBinding {
    #[doc(alias = "VTE_ERASE_AUTO")]
    Auto,
    #[doc(alias = "VTE_ERASE_ASCII_BACKSPACE")]
    AsciiBackspace,
    #[doc(alias = "VTE_ERASE_ASCII_DELETE")]
    AsciiDelete,
    #[doc(alias = "VTE_ERASE_DELETE_SEQUENCE")]
    DeleteSequence,
    #[doc(alias = "VTE_ERASE_TTY")]
    Tty,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EraseBinding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "EraseBinding::{}", match *self {
            Self::Auto => "Auto",
            Self::AsciiBackspace => "AsciiBackspace",
            Self::AsciiDelete => "AsciiDelete",
            Self::DeleteSequence => "DeleteSequence",
            Self::Tty => "Tty",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for EraseBinding {
    type GlibType = VteEraseBinding;

    #[inline]
fn into_glib(self) -> VteEraseBinding {
match self {
            Self::Auto => VTE_ERASE_AUTO,
            Self::AsciiBackspace => VTE_ERASE_ASCII_BACKSPACE,
            Self::AsciiDelete => VTE_ERASE_ASCII_DELETE,
            Self::DeleteSequence => VTE_ERASE_DELETE_SEQUENCE,
            Self::Tty => VTE_ERASE_TTY,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<VteEraseBinding> for EraseBinding {
    #[inline]
unsafe fn from_glib(value: VteEraseBinding) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_ERASE_AUTO => Self::Auto,
            VTE_ERASE_ASCII_BACKSPACE => Self::AsciiBackspace,
            VTE_ERASE_ASCII_DELETE => Self::AsciiDelete,
            VTE_ERASE_DELETE_SEQUENCE => Self::DeleteSequence,
            VTE_ERASE_TTY => Self::Tty,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for EraseBinding {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_erase_binding_get_type()) }
    }
}

impl glib::HasParamSpec for EraseBinding {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

impl glib::value::ValueType for EraseBinding {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EraseBinding {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EraseBinding {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EraseBinding> for glib::Value {
    #[inline]
    fn from(v: EraseBinding) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteFormat")]
pub enum Format {
    #[doc(alias = "VTE_FORMAT_TEXT")]
    Text,
    #[doc(alias = "VTE_FORMAT_HTML")]
    Html,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Format::{}", match *self {
            Self::Text => "Text",
            Self::Html => "Html",
            _ => "Unknown",
        })
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl IntoGlib for Format {
    type GlibType = VteFormat;

    #[inline]
fn into_glib(self) -> VteFormat {
match self {
            Self::Text => VTE_FORMAT_TEXT,
            Self::Html => VTE_FORMAT_HTML,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl FromGlib<VteFormat> for Format {
    #[inline]
unsafe fn from_glib(value: VteFormat) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_FORMAT_TEXT => Self::Text,
            VTE_FORMAT_HTML => Self::Html,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl StaticType for Format {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_format_get_type()) }
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl glib::HasParamSpec for Format {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl glib::value::ValueType for Format {
    type Type = Self;
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
unsafe impl<'a> glib::value::FromValue<'a> for Format {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl ToValue for Format {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_50")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_50")))]
impl From<Format> for glib::Value {
    #[inline]
    fn from(v: Format) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePtyError")]
pub enum PtyError {
    #[doc(alias = "VTE_PTY_ERROR_PTY_HELPER_FAILED")]
    PtyHelperFailed,
    #[doc(alias = "VTE_PTY_ERROR_PTY98_FAILED")]
    Pty98Failed,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PtyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PtyError::{}", match *self {
            Self::PtyHelperFailed => "PtyHelperFailed",
            Self::Pty98Failed => "Pty98Failed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for PtyError {
    type GlibType = VtePtyError;

    #[inline]
fn into_glib(self) -> VtePtyError {
match self {
            Self::PtyHelperFailed => VTE_PTY_ERROR_PTY_HELPER_FAILED,
            Self::Pty98Failed => VTE_PTY_ERROR_PTY98_FAILED,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<VtePtyError> for PtyError {
    #[inline]
unsafe fn from_glib(value: VtePtyError) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_PTY_ERROR_PTY_HELPER_FAILED => Self::PtyHelperFailed,
            VTE_PTY_ERROR_PTY98_FAILED => Self::Pty98Failed,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for PtyError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(vte_pty_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
}
    }
}

impl StaticType for PtyError {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_pty_error_get_type()) }
    }
}

impl glib::HasParamSpec for PtyError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

impl glib::value::ValueType for PtyError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PtyError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PtyError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PtyError> for glib::Value {
    #[inline]
    fn from(v: PtyError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteRegexError")]
pub enum RegexError {
    #[doc(alias = "VTE_REGEX_ERROR_INCOMPATIBLE")]
    Incompatible,
    #[doc(alias = "VTE_REGEX_ERROR_NOT_SUPPORTED")]
    NotSupported,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl fmt::Display for RegexError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "RegexError::{}", match *self {
            Self::Incompatible => "Incompatible",
            Self::NotSupported => "NotSupported",
            _ => "Unknown",
        })
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[doc(hidden)]
impl IntoGlib for RegexError {
    type GlibType = VteRegexError;

    #[inline]
fn into_glib(self) -> VteRegexError {
match self {
            Self::Incompatible => VTE_REGEX_ERROR_INCOMPATIBLE,
            Self::NotSupported => VTE_REGEX_ERROR_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
#[doc(hidden)]
impl FromGlib<VteRegexError> for RegexError {
    #[inline]
unsafe fn from_glib(value: VteRegexError) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_REGEX_ERROR_INCOMPATIBLE => Self::Incompatible,
            VTE_REGEX_ERROR_NOT_SUPPORTED => Self::NotSupported,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::error::ErrorDomain for RegexError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(vte_regex_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
}
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl StaticType for RegexError {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_regex_error_get_type()) }
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::HasParamSpec for RegexError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl glib::value::ValueType for RegexError {
    type Type = Self;
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
unsafe impl<'a> glib::value::FromValue<'a> for RegexError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl ToValue for RegexError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_46")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_46")))]
impl From<RegexError> for glib::Value {
    #[inline]
    fn from(v: RegexError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteTextBlinkMode")]
pub enum TextBlinkMode {
    #[doc(alias = "VTE_TEXT_BLINK_NEVER")]
    Never,
    #[doc(alias = "VTE_TEXT_BLINK_FOCUSED")]
    Focused,
    #[doc(alias = "VTE_TEXT_BLINK_UNFOCUSED")]
    Unfocused,
    #[doc(alias = "VTE_TEXT_BLINK_ALWAYS")]
    Always,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl fmt::Display for TextBlinkMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "TextBlinkMode::{}", match *self {
            Self::Never => "Never",
            Self::Focused => "Focused",
            Self::Unfocused => "Unfocused",
            Self::Always => "Always",
            _ => "Unknown",
        })
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl IntoGlib for TextBlinkMode {
    type GlibType = VteTextBlinkMode;

    #[inline]
fn into_glib(self) -> VteTextBlinkMode {
match self {
            Self::Never => VTE_TEXT_BLINK_NEVER,
            Self::Focused => VTE_TEXT_BLINK_FOCUSED,
            Self::Unfocused => VTE_TEXT_BLINK_UNFOCUSED,
            Self::Always => VTE_TEXT_BLINK_ALWAYS,
            Self::__Unknown(value) => value,
}
}
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl FromGlib<VteTextBlinkMode> for TextBlinkMode {
    #[inline]
unsafe fn from_glib(value: VteTextBlinkMode) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_TEXT_BLINK_NEVER => Self::Never,
            VTE_TEXT_BLINK_FOCUSED => Self::Focused,
            VTE_TEXT_BLINK_UNFOCUSED => Self::Unfocused,
            VTE_TEXT_BLINK_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
}
}
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl StaticType for TextBlinkMode {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_text_blink_mode_get_type()) }
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl glib::HasParamSpec for TextBlinkMode {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl glib::value::ValueType for TextBlinkMode {
    type Type = Self;
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
unsafe impl<'a> glib::value::FromValue<'a> for TextBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl ToValue for TextBlinkMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v0_52")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_52")))]
impl From<TextBlinkMode> for glib::Value {
    #[inline]
    fn from(v: TextBlinkMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteWriteFlags")]
pub enum WriteFlags {
    #[doc(alias = "VTE_WRITE_DEFAULT")]
    Default,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WriteFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WriteFlags::{}", match *self {
            Self::Default => "Default",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for WriteFlags {
    type GlibType = VteWriteFlags;

    #[inline]
fn into_glib(self) -> VteWriteFlags {
match self {
            Self::Default => VTE_WRITE_DEFAULT,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<VteWriteFlags> for WriteFlags {
    #[inline]
unsafe fn from_glib(value: VteWriteFlags) -> Self {
        skip_assert_initialized!();
        
match value {
            VTE_WRITE_DEFAULT => Self::Default,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for WriteFlags {
    #[inline]
    fn static_type() -> glib::Type {
        unsafe { from_glib(vte_write_flags_get_type()) }
    }
}

impl glib::HasParamSpec for WriteFlags {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name, default_value| Self::ParamSpec::builder_with_default(name, default_value)
                }
}

impl glib::value::ValueType for WriteFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WriteFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WriteFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WriteFlags> for glib::Value {
    #[inline]
    fn from(v: WriteFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

